// Generated by gencpp from file state_estimator_msgs/ForwardKinematics.msg
// DO NOT EDIT!


#ifndef STATE_ESTIMATOR_MSGS_MESSAGE_FORWARDKINEMATICS_H
#define STATE_ESTIMATOR_MSGS_MESSAGE_FORWARDKINEMATICS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace state_estimator_msgs
{
template <class ContainerAllocator>
struct ForwardKinematics_
{
  typedef ForwardKinematics_<ContainerAllocator> Type;

  ForwardKinematics_()
    : lf_haa()
    , rf_haa()
    , lh_haa()
    , rh_haa()
    , lf_hfe()
    , rf_hfe()
    , lh_hfe()
    , rh_hfe()
    , lf_kfe()
    , rf_kfe()
    , lh_kfe()
    , rh_kfe()
    , lf_foot()
    , rf_foot()
    , lh_foot()
    , rh_foot()  {
      lf_haa.assign(0.0);

      rf_haa.assign(0.0);

      lh_haa.assign(0.0);

      rh_haa.assign(0.0);

      lf_hfe.assign(0.0);

      rf_hfe.assign(0.0);

      lh_hfe.assign(0.0);

      rh_hfe.assign(0.0);

      lf_kfe.assign(0.0);

      rf_kfe.assign(0.0);

      lh_kfe.assign(0.0);

      rh_kfe.assign(0.0);

      lf_foot.assign(0.0);

      rf_foot.assign(0.0);

      lh_foot.assign(0.0);

      rh_foot.assign(0.0);
  }
  ForwardKinematics_(const ContainerAllocator& _alloc)
    : lf_haa()
    , rf_haa()
    , lh_haa()
    , rh_haa()
    , lf_hfe()
    , rf_hfe()
    , lh_hfe()
    , rh_hfe()
    , lf_kfe()
    , rf_kfe()
    , lh_kfe()
    , rh_kfe()
    , lf_foot()
    , rf_foot()
    , lh_foot()
    , rh_foot()  {
  (void)_alloc;
      lf_haa.assign(0.0);

      rf_haa.assign(0.0);

      lh_haa.assign(0.0);

      rh_haa.assign(0.0);

      lf_hfe.assign(0.0);

      rf_hfe.assign(0.0);

      lh_hfe.assign(0.0);

      rh_hfe.assign(0.0);

      lf_kfe.assign(0.0);

      rf_kfe.assign(0.0);

      lh_kfe.assign(0.0);

      rh_kfe.assign(0.0);

      lf_foot.assign(0.0);

      rf_foot.assign(0.0);

      lh_foot.assign(0.0);

      rh_foot.assign(0.0);
  }



   typedef boost::array<double, 16>  _lf_haa_type;
  _lf_haa_type lf_haa;

   typedef boost::array<double, 16>  _rf_haa_type;
  _rf_haa_type rf_haa;

   typedef boost::array<double, 16>  _lh_haa_type;
  _lh_haa_type lh_haa;

   typedef boost::array<double, 16>  _rh_haa_type;
  _rh_haa_type rh_haa;

   typedef boost::array<double, 16>  _lf_hfe_type;
  _lf_hfe_type lf_hfe;

   typedef boost::array<double, 16>  _rf_hfe_type;
  _rf_hfe_type rf_hfe;

   typedef boost::array<double, 16>  _lh_hfe_type;
  _lh_hfe_type lh_hfe;

   typedef boost::array<double, 16>  _rh_hfe_type;
  _rh_hfe_type rh_hfe;

   typedef boost::array<double, 16>  _lf_kfe_type;
  _lf_kfe_type lf_kfe;

   typedef boost::array<double, 16>  _rf_kfe_type;
  _rf_kfe_type rf_kfe;

   typedef boost::array<double, 16>  _lh_kfe_type;
  _lh_kfe_type lh_kfe;

   typedef boost::array<double, 16>  _rh_kfe_type;
  _rh_kfe_type rh_kfe;

   typedef boost::array<double, 16>  _lf_foot_type;
  _lf_foot_type lf_foot;

   typedef boost::array<double, 16>  _rf_foot_type;
  _rf_foot_type rf_foot;

   typedef boost::array<double, 16>  _lh_foot_type;
  _lh_foot_type lh_foot;

   typedef boost::array<double, 16>  _rh_foot_type;
  _rh_foot_type rh_foot;





  typedef boost::shared_ptr< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> const> ConstPtr;

}; // struct ForwardKinematics_

typedef ::state_estimator_msgs::ForwardKinematics_<std::allocator<void> > ForwardKinematics;

typedef boost::shared_ptr< ::state_estimator_msgs::ForwardKinematics > ForwardKinematicsPtr;
typedef boost::shared_ptr< ::state_estimator_msgs::ForwardKinematics const> ForwardKinematicsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator1> & lhs, const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator2> & rhs)
{
  return lhs.lf_haa == rhs.lf_haa &&
    lhs.rf_haa == rhs.rf_haa &&
    lhs.lh_haa == rhs.lh_haa &&
    lhs.rh_haa == rhs.rh_haa &&
    lhs.lf_hfe == rhs.lf_hfe &&
    lhs.rf_hfe == rhs.rf_hfe &&
    lhs.lh_hfe == rhs.lh_hfe &&
    lhs.rh_hfe == rhs.rh_hfe &&
    lhs.lf_kfe == rhs.lf_kfe &&
    lhs.rf_kfe == rhs.rf_kfe &&
    lhs.lh_kfe == rhs.lh_kfe &&
    lhs.rh_kfe == rhs.rh_kfe &&
    lhs.lf_foot == rhs.lf_foot &&
    lhs.rf_foot == rhs.rf_foot &&
    lhs.lh_foot == rhs.lh_foot &&
    lhs.rh_foot == rhs.rh_foot;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator1> & lhs, const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace state_estimator_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ae408d1e170b8d8b6fa4c83a5b6670c0";
  }

  static const char* value(const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xae408d1e170b8d8bULL;
  static const uint64_t static_value2 = 0x6fa4c83a5b6670c0ULL;
};

template<class ContainerAllocator>
struct DataType< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
{
  static const char* value()
  {
    return "state_estimator_msgs/ForwardKinematics";
  }

  static const char* value(const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64[16] lf_haa\n"
"float64[16] rf_haa\n"
"float64[16] lh_haa\n"
"float64[16] rh_haa\n"
"\n"
"float64[16] lf_hfe\n"
"float64[16] rf_hfe\n"
"float64[16] lh_hfe\n"
"float64[16] rh_hfe\n"
"\n"
"float64[16] lf_kfe\n"
"float64[16] rf_kfe\n"
"float64[16] lh_kfe\n"
"float64[16] rh_kfe\n"
"\n"
"float64[16] lf_foot\n"
"float64[16] rf_foot\n"
"float64[16] lh_foot\n"
"float64[16] rh_foot\n"
;
  }

  static const char* value(const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.lf_haa);
      stream.next(m.rf_haa);
      stream.next(m.lh_haa);
      stream.next(m.rh_haa);
      stream.next(m.lf_hfe);
      stream.next(m.rf_hfe);
      stream.next(m.lh_hfe);
      stream.next(m.rh_hfe);
      stream.next(m.lf_kfe);
      stream.next(m.rf_kfe);
      stream.next(m.lh_kfe);
      stream.next(m.rh_kfe);
      stream.next(m.lf_foot);
      stream.next(m.rf_foot);
      stream.next(m.lh_foot);
      stream.next(m.rh_foot);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ForwardKinematics_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::state_estimator_msgs::ForwardKinematics_<ContainerAllocator>& v)
  {
    s << indent << "lf_haa[]" << std::endl;
    for (size_t i = 0; i < v.lf_haa.size(); ++i)
    {
      s << indent << "  lf_haa[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lf_haa[i]);
    }
    s << indent << "rf_haa[]" << std::endl;
    for (size_t i = 0; i < v.rf_haa.size(); ++i)
    {
      s << indent << "  rf_haa[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rf_haa[i]);
    }
    s << indent << "lh_haa[]" << std::endl;
    for (size_t i = 0; i < v.lh_haa.size(); ++i)
    {
      s << indent << "  lh_haa[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lh_haa[i]);
    }
    s << indent << "rh_haa[]" << std::endl;
    for (size_t i = 0; i < v.rh_haa.size(); ++i)
    {
      s << indent << "  rh_haa[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rh_haa[i]);
    }
    s << indent << "lf_hfe[]" << std::endl;
    for (size_t i = 0; i < v.lf_hfe.size(); ++i)
    {
      s << indent << "  lf_hfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lf_hfe[i]);
    }
    s << indent << "rf_hfe[]" << std::endl;
    for (size_t i = 0; i < v.rf_hfe.size(); ++i)
    {
      s << indent << "  rf_hfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rf_hfe[i]);
    }
    s << indent << "lh_hfe[]" << std::endl;
    for (size_t i = 0; i < v.lh_hfe.size(); ++i)
    {
      s << indent << "  lh_hfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lh_hfe[i]);
    }
    s << indent << "rh_hfe[]" << std::endl;
    for (size_t i = 0; i < v.rh_hfe.size(); ++i)
    {
      s << indent << "  rh_hfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rh_hfe[i]);
    }
    s << indent << "lf_kfe[]" << std::endl;
    for (size_t i = 0; i < v.lf_kfe.size(); ++i)
    {
      s << indent << "  lf_kfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lf_kfe[i]);
    }
    s << indent << "rf_kfe[]" << std::endl;
    for (size_t i = 0; i < v.rf_kfe.size(); ++i)
    {
      s << indent << "  rf_kfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rf_kfe[i]);
    }
    s << indent << "lh_kfe[]" << std::endl;
    for (size_t i = 0; i < v.lh_kfe.size(); ++i)
    {
      s << indent << "  lh_kfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lh_kfe[i]);
    }
    s << indent << "rh_kfe[]" << std::endl;
    for (size_t i = 0; i < v.rh_kfe.size(); ++i)
    {
      s << indent << "  rh_kfe[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rh_kfe[i]);
    }
    s << indent << "lf_foot[]" << std::endl;
    for (size_t i = 0; i < v.lf_foot.size(); ++i)
    {
      s << indent << "  lf_foot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lf_foot[i]);
    }
    s << indent << "rf_foot[]" << std::endl;
    for (size_t i = 0; i < v.rf_foot.size(); ++i)
    {
      s << indent << "  rf_foot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rf_foot[i]);
    }
    s << indent << "lh_foot[]" << std::endl;
    for (size_t i = 0; i < v.lh_foot.size(); ++i)
    {
      s << indent << "  lh_foot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lh_foot[i]);
    }
    s << indent << "rh_foot[]" << std::endl;
    for (size_t i = 0; i < v.rh_foot.size(); ++i)
    {
      s << indent << "  rh_foot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.rh_foot[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // STATE_ESTIMATOR_MSGS_MESSAGE_FORWARDKINEMATICS_H
